<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rewired Studio Monitor</title>
    <style>
        :root { --bg: #0a0a0a; --card: #161616; --accent: #007aff; --text: #ffffff; }
        body { font-family: -apple-system, system-ui; background: var(--bg); color: var(--text); display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; margin: 0; padding: 20px; box-sizing: border-box; }
        .container { background: var(--card); padding: 30px; border-radius: 24px; text-align: center; width: 100%; max-width: 360px; box-shadow: 0 20px 40px rgba(0,0,0,0.4); border: 1px solid #333; position: relative; }
        h1 { font-size: 1.1rem; font-weight: 600; margin-bottom: 4px; color: #fff; text-transform: uppercase; letter-spacing: 1px; }
        
        .subtitle { font-size: 0.8rem; color: #888; margin-bottom: 20px; }
        .subtitle b { color: var(--accent); }

        .input-group { margin-bottom: 15px; text-align: left; }
        label { display: block; font-size: 0.75rem; color: #666; margin-bottom: 5px; margin-left: 4px; text-transform: uppercase; }
        input { width: 100%; padding: 12px; background: #222; border: 1px solid #333; border-radius: 10px; color: white; font-size: 1rem; box-sizing: border-box; }
        
        .meter-stack { display: flex; gap: 4px; justify-content: center; height: 100px; margin: 20px 0; }
        .meter { width: 12px; background: #222; border-radius: 4px; position: relative; overflow: hidden; }
        .meter-fill { width: 100%; position: absolute; bottom: 0; background: linear-gradient(to top, #34c759 0%, #34c759 70%, #ffcc00 85%, #ff3b30 100%); transition: height 0.08s ease-out; }

        .status { font-size: 0.85rem; margin-bottom: 20px; color: #666; font-weight: 500; }
        .status.online { color: #34c759; }
        .status.connecting { color: #ff9500; }
        .status.error { color: #ff3b30; }
        .status.paused { color: #ffcc00; }

        .roster-container { margin-top: 20px; text-align: left; border-top: 1px solid #333; padding-top: 15px; }
        .roster-title { font-size: 0.7rem; color: #555; font-weight: bold; margin-bottom: 10px; text-transform: uppercase; }
        .roster-list { list-style: none; padding: 0; margin: 0; font-size: 0.85rem; }
        .roster-item { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; color: #ccc; }
        .roster-icon { width: 8px; height: 8px; border-radius: 50%; background: #444; }
        .roster-icon.sender { background: #007aff; box-shadow: 0 0 5px #007aff; }
        .roster-item b { color: #fff; font-weight: 500; }

        button { background: var(--accent); color: white; border: none; padding: 16px; border-radius: 14px; font-size: 1rem; font-weight: 600; cursor: pointer; width: 100%; -webkit-tap-highlight-color: transparent; }
        button:disabled { background: #333; color: #666; }
        button:active { transform: scale(0.98); }
        
        /* Mute/Pause Overlay */
        #control-bar { display: none; margin-top: 15px; justify-content: center; gap: 10px; }
        .icon-btn { background: #333; width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; border: 1px solid #444; }
        .icon-btn.active { background: #007aff; border-color: #007aff; }
        .icon-btn.paused { background: #ffcc00; color: #000; border-color: #ffcc00; }
        
        #debug-console { width: 100%; max-width: 360px; height: 120px; background: #000; color: #0f0; font-family: monospace; font-size: 10px; padding: 10px; margin-top: 20px; border-radius: 8px; overflow-y: auto; border: 1px solid #333; text-align: left; }
    </style>
</head>
<body>

<div class="container">
    <h1>Studio Monitor</h1>
    <div id="subtitle" class="subtitle">Not Connected</div>
    
    <div id="inputs">
        <div class="input-group">
            <label>Room Name</label>
            <input type="text" id="room-input" value="studio1">
        </div>
        <div class="input-group">
            <label>Your Name</label>
            <input type="text" id="name-input" placeholder="Enter name...">
        </div>
    </div>

    <div id="meter-display" class="meter-stack" style="display:none;">
        <div class="meter"><div id="fill-l" class="meter-fill" style="height: 0%"></div></div>
        <div class="meter"><div id="fill-r" class="meter-fill" style="height: 0%"></div></div>
    </div>

    <div id="status" class="status">Idle</div>
    <button id="join-btn">Listen Live</button>
    
    <div id="control-bar">
        <button id="mute-btn" class="icon-btn active" title="Toggle Playback">
            üîä
        </button>
    </div>

    <div class="roster-container" id="roster-view" style="display:none;">
        <div class="roster-title">Room Roster</div>
        <ul id="roster-list" class="roster-list"></ul>
    </div>
</div>

<div id="debug-console"></div>
<audio id="remote-audio" autoplay playsinline></audio>

<script>
    // 1. Global Error Handler
    window.onerror = function(message, source, lineno, colno, error) {
        log(`CRITICAL ERROR: ${message}`, 'error');
        console.error(error);
    };

    const consoleEl = document.getElementById('debug-console');
    const statusLabel = document.getElementById('status');
    const subtitleLabel = document.getElementById('subtitle');
    const rosterList = document.getElementById('roster-list');
    const audioEl = document.getElementById('remote-audio');
    const muteBtn = document.getElementById('mute-btn');
    const controlBar = document.getElementById('control-bar');

    // 2. Safe ID Generator
    function generateId() {
        if (typeof crypto !== 'undefined' && crypto.randomUUID) {
            return crypto.randomUUID();
        }
        return 'user-' + Math.random().toString(36).substr(2, 9);
    }

    // 3. Render-Compatible URL Detector
    function getServerUrl() {
        return window.location.origin.replace(/^http/, 'ws');
    }

    const myId = generateId();
    const serverUrl = getServerUrl();
    
    let socket, pc, audioCtx;
    let isPlaying = true;

    function log(msg, type = 'info') {
        const entry = document.createElement('div');
        entry.innerText = `> ${msg}`;
        if (type === 'error') entry.style.color = '#ff3b30';
        if (type === 'warn') entry.style.color = '#ffcc00';
        consoleEl.prepend(entry);
        console.log(msg);
    }

    log(`System Ready. ID: ${myId.substring(0,4)}...`);
    log(`Target Server: ${serverUrl}`);

    // --- PAUSE / RESUME LOGIC ---
    muteBtn.addEventListener('click', () => {
        if (audioEl.paused) {
            // RESUME
            audioEl.play().then(() => {
                muteBtn.innerHTML = "üîä";
                muteBtn.className = "icon-btn active";
                statusLabel.innerText = "Live Stream Active";
                statusLabel.className = "status online";
                log("Audio Resumed ‚ñ∂Ô∏è");
                
                // Ensure context is running (iOS fix)
                if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
            }).catch(e => log(`Resume Failed: ${e.message}`, 'error'));
        } else {
            // PAUSE
            audioEl.pause();
            muteBtn.innerHTML = "‚è∏Ô∏è";
            muteBtn.className = "icon-btn paused";
            statusLabel.innerText = "Playback Paused";
            statusLabel.className = "status paused";
            log("Audio Paused ‚è∏Ô∏è");
        }
    });

    document.getElementById('join-btn').addEventListener('click', async () => {
        log("Button Clicked. Starting...");
        const roomName = document.getElementById('room-input').value.trim();
        const userName = document.getElementById('name-input').value.trim();

        if (!roomName || !userName) {
            log("Error: Name and Room required", "error");
            return;
        }

        document.getElementById('join-btn').disabled = true;
        statusLabel.innerText = "Connecting...";
        statusLabel.className = "status connecting";
        subtitleLabel.innerHTML = `Connecting to <b>${roomName}</b> as <b>${userName}</b>`;
        
        try {
            // Initialize Audio Context on User Gesture (Required for iOS)
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') await audioCtx.resume();
            log("Audio Context Started ‚úÖ");
            initSignaling(roomName, userName);
        } catch (e) {
            log(`Init Error: ${e.message}`, 'error');
            statusLabel.innerText = "Connection Failed";
            statusLabel.className = "status error";
            document.getElementById('join-btn').disabled = false;
        }
    });

    function initSignaling(room, name) {
        log(`Dialing WebSocket: ${serverUrl}`);
        socket = new WebSocket(serverUrl);

        socket.onopen = () => {
            log("WebSocket Connected ‚úÖ");
            socket.send(JSON.stringify({
                type: "join",
                room: room,
                name: name,
                id: myId,
                role: "receiver"
            }));
        };

        socket.onmessage = async (event) => {
            const msg = JSON.parse(event.data);
            if (msg.id === myId && msg.type !== "roster-update") return;

            switch (msg.type) {
                case "roster-update":
                    updateRosterUI(msg.roster);
                    break;
                case "offer":
                    log("Received Offer from Sender");
                    handleOffer(msg.sdp, msg.id);
                    break;
                case "candidate":
                    if (pc) await pc.addIceCandidate(new RTCIceCandidate(msg));
                    break;
            }
        };

        socket.onerror = (e) => {
            log("WebSocket Error. Check Server URL.", "error");
            statusLabel.innerText = "Server Error";
            statusLabel.className = "status error";
        };

        socket.onclose = () => {
            log("WebSocket Disconnected", "warn");
            statusLabel.innerText = "Disconnected";
            statusLabel.className = "status";
            document.getElementById('join-btn').disabled = false;
        };
    }

    function updateRosterUI(roster) {
        rosterList.innerHTML = '';
        document.getElementById('roster-view').style.display = 'block';
        roster.forEach(peer => {
            const item = document.createElement('li');
            item.className = 'roster-item';
            const isSender = peer.role === 'duplex' || peer.name.includes('(You)');
            const icon = document.createElement('div');
            icon.className = `roster-icon ${isSender ? 'sender' : ''}`;
            item.appendChild(icon);
            item.innerHTML += `<b>${peer.name}</b> ${isSender ? 'üì°' : 'üéß'}`;
            rosterList.appendChild(item);
        });
    }

    async function handleOffer(sdp, senderId) {
        log("Negotiating WebRTC...");
        pc = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });

        pc.onicecandidate = (e) => {
            if (e.candidate) socket.send(JSON.stringify({ ...e.candidate.toJSON(), type: 'candidate', id: myId, targetId: senderId }));
        };

        pc.onconnectionstatechange = () => {
            log(`Connection State: ${pc.connectionState}`);
            if (pc.connectionState === 'connected') {
                statusLabel.innerText = "Live Stream Active";
                statusLabel.className = "status online";
            }
        };

        pc.ontrack = (event) => {
            log("Audio Track Received! üîà");
            document.getElementById('inputs').style.display = 'none';
            document.getElementById('meter-display').style.display = 'flex';
            
            // Show Mute Controls
            controlBar.style.display = "flex";

            document.getElementById('remote-audio').srcObject = event.streams[0];
            
            // --- INJECTED FUNCTIONALITY START ---
            setupMetering(event.streams[0]);
            startDiagnostics(event.streams[0], pc);
            // --- INJECTED FUNCTIONALITY END ---
        };

        await pc.setRemoteDescription(new RTCSessionDescription({ type: "offer", sdp: sdp }));
        const answer = await pc.createAnswer();
        
        // Munge SDP for High Fidelity (Stereo, 510kbps)
        answer.sdp = answer.sdp.replace("useinbandfec=1", "useinbandfec=1;stereo=1;sprop-stereo=1;maxaveragebitrate=510000");
        
        await pc.setLocalDescription(answer);
        socket.send(JSON.stringify({ type: "answer", sdp: answer.sdp, id: myId, targetId: senderId }));
    }

    function setupMetering(stream) {
        // [FIX] Audio routing for iPhone/iOS
        const source = audioCtx.createMediaStreamSource(stream);
        // 1. CRITICAL: Connect Source to Destination (Speakers) so audio plays
        source.connect(audioCtx.destination);
        
        // 2. Connect Source to Splitter for Metering
        const splitter = audioCtx.createChannelSplitter(2);
        source.connect(splitter);

        const analyze = (idx, el) => {
            const proc = audioCtx.createAnalyser();
            proc.fftSize = 256;
            splitter.connect(proc, idx);
            const data = new Uint8Array(proc.frequencyBinCount);
            
            const draw = () => {
                proc.getByteFrequencyData(data);
                const avg = data.reduce((a, b) => a + b) / data.length;
                el.style.height = Math.min(Math.sqrt(avg / 255) * 100, 100) + "%";
                requestAnimationFrame(draw);
            };
            draw();
        };

        analyze(0, document.getElementById('fill-l'));
        analyze(1, document.getElementById('fill-r'));
    }

    // --- NEW DIAGNOSTIC FUNCTION ---
    function startDiagnostics(stream, peerConnection) {
        log("üïµÔ∏è Diagnostics Started: Monitor enabled", "info");

        // 1. Digital Silence Detection (Source Issue)
        // We create a SEPARATE analyser to avoid messing with visualizers
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 256; 
        const source = audioCtx.createMediaStreamSource(stream);
        source.connect(analyser); // Monitor stream

        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        let silenceCount = 0;

        setInterval(() => {
            analyser.getByteTimeDomainData(dataArray);
            
            // Check for "128" (Zero in 8-bit PCM)
            let isDigitalSilence = true;
            for(let i=0; i<dataArray.length; i++) {
                if(dataArray[i] !== 128) { isDigitalSilence = false; break; }
            }

            if (isDigitalSilence) {
                silenceCount++;
                // 20 checks * 100ms = 2 seconds of pure zeros
                if (silenceCount === 20) {
                    log("üîá ALERT: Digital Silence Detected! (Logic Output is 0)", "error");
                }
            } else {
                if (silenceCount >= 20) {
                    log("üîä Audio Recovered", "info");
                }
                silenceCount = 0;
            }
        }, 100);

        // 2. Network Health Monitor (Transport Issue)
        setInterval(async () => {
            if (peerConnection.connectionState !== 'connected') return;

            const stats = await peerConnection.getStats();
            stats.forEach(report => {
                if (report.type === 'inbound-rtp' && report.kind === 'audio') {
                    const lost = report.packetsLost;
                    const jitter = report.jitter;

                    // Only log if significant issues are detected
                    if (lost > 5 && Math.random() > 0.9) { // Throttle logs
                        log(`‚ö†Ô∏è PACKET LOSS: ${lost} packets`, "warn");
                    }
                    if (jitter > 0.1 && Math.random() > 0.9) {
                        log(`‚ö†Ô∏è HIGH JITTER: ${(jitter * 1000).toFixed(0)}ms`, "warn");
                    }
                }
            });
        }, 1000);
    }
</script>
</body>
</html>
