import Foundation
import Network
import Combine
import WebRTC

public struct PeerUser: Identifiable, Hashable, Codable {
    public let id: String
    public let name: String
    public let role: String
    public var isBroadcasting: Bool = false
    public var isMicEnabled: Bool = true
    public var isMusicEnabled: Bool = true
    public var effectiveBitrate: String = "0 kbps"
    public var connectionState: RTCIceConnectionState = .new
    
    enum CodingKeys: String, CodingKey {
        case id, name, role, isBroadcasting, isMicEnabled, isMusicEnabled, effectiveBitrate
    }
    
    public init(id: String, name: String, role: String, isBroadcasting: Bool = false, isMicEnabled: Bool = true, isMusicEnabled: Bool = true, effectiveBitrate: String = "0 kbps") {
        self.id = id
        self.name = name
        self.role = role
        self.isBroadcasting = isBroadcasting
        self.isMicEnabled = isMicEnabled
        self.isMusicEnabled = isMusicEnabled
        self.effectiveBitrate = effectiveBitrate
    }
}

@MainActor
class NwSessionCoordinator: NSObject, ObservableObject {
    @Published var isConnected = false
    @Published var connectionStatus: String = "Idle"
    @Published var roster: [PeerUser] = []
    
    // Stats for UI
    @Published var txBitrate: String = "0 kbps"
    @Published var rxBitrate: String = "0 kbps"
    @Published var activePeerCount: Int = 0
    
    public private(set) var myId: String = ""
    
    // Saved Connection Params for Reconnect Logic
    private var savedServerURL: String = ""
    private var savedRoomName: String = ""
    private var savedUserName: String = ""
    private var isIntentionalDisconnect: Bool = false
    private var reconnectWorkItem: DispatchWorkItem?
    
    let audioCaptureService: AudioCaptureService
    
    private var peerConnectionFactory: RTCPeerConnectionFactory
    private var peerConnections: [String: RTCPeerConnection] = [:]
    private var localAudioTrack: RTCAudioTrack?
    private var webSocketTask: URLSessionWebSocketTask?
    private var statsSource: DispatchSourceTimer?
    private var keepAliveTimer: Timer?
    private var pendingIceCandidates: [String: [RTCIceCandidate]] = [:]
    
    // High-Fidelity Constraints
    private var mediaConstraints: RTCMediaConstraints {
        let constraints = [
            "googEchoCancellation": "false",
            "googAutoGainControl": "false",
            "googNoiseSuppression": "false",
            "googHighpassFilter": "false"
        ]
        return RTCMediaConstraints(mandatoryConstraints: constraints, optionalConstraints: nil)
    }
    
    init(audioService: AudioCaptureService) {
        self.audioCaptureService = audioService
        
        let vEnc = RTCDefaultVideoEncoderFactory()
        let vDec = RTCDefaultVideoDecoderFactory()
        self.peerConnectionFactory = RTCPeerConnectionFactory(encoderFactory: vEnc, decoderFactory: vDec)
        
        super.init()
        LogStore.log("üü¶ Coordinator: WebRTC Factory Initialized", type: .info)
    }
    
    private func setupLocalTrack() {
        if localAudioTrack != nil { return }
        LogStore.log("üéô Coordinator: Creating Local Audio Track...", type: .info)
        
        let source = peerConnectionFactory.audioSource(with: mediaConstraints)
        self.localAudioTrack = peerConnectionFactory.audioTrack(with: source, trackId: "ARDAMSa0")
        self.localAudioTrack?.isEnabled = true
        
        if self.localAudioTrack != nil {
            LogStore.log("‚úÖ Coordinator: Local Audio Track Created", type: .success)
        } else {
            LogStore.log("‚ùå Coordinator: Failed to Create Audio Track", type: .error)
        }
    }
    
    func setMicEnabled(_ isEnabled: Bool) {
        broadcastStatus()
    }
    
    // Helper to resolve ID to Name for Logs
    private func getName(for id: String) -> String {
        return roster.first(where: { $0.id == id })?.name ?? id
    }
    
    func connect(server: String, room: String, name: String) async {
        self.savedServerURL = server
        self.savedRoomName = room
        self.savedUserName = name
        self.isIntentionalDisconnect = false
        
        reconnectWorkItem?.cancel()
        reconnectWorkItem = nil
        
        LogStore.log("üåê Coordinator: Connecting to \(server)...", type: .net)
        self.connectionStatus = "Connecting..."
        guard let url = URL(string: server) else {
            self.connectionStatus = "Invalid URL"
            return
        }
        
        setupLocalTrack()
        
        if self.myId.isEmpty { self.myId = UUID().uuidString }
        
        let session = URLSession(configuration: .default)
        webSocketTask = session.webSocketTask(with: url)
        webSocketTask?.resume()
        listenSocket()
        
        let joinMsg: [String: Any] = [
            "type": "join", "room": room, "name": name,
            "role": "duplex", "id": self.myId,
            "isBroadcasting": true, "isMicEnabled": false, "isMusicEnabled": true
        ]
        
        try? await Task.sleep(nanoseconds: 200_000_000)
        sendJson(joinMsg)
        
        self.connectionStatus = "Signal Connected (Waiting for Peers)"
        
        if !roster.contains(where: { $0.id == self.myId }) {
            let me = PeerUser(id: self.myId, name: "\(name) (You)", role: "duplex", isBroadcasting: true)
            self.roster.append(me)
        }
        
        startStatsPoller()
        startKeepAlive()
    }

    func disconnect() {
        LogStore.log("üõë Coordinator: Disconnect Requested", type: .net)
        
        isIntentionalDisconnect = true
        reconnectWorkItem?.cancel()
        reconnectWorkItem = nil
        
        statsSource?.cancel()
        statsSource = nil
        
        keepAliveTimer?.invalidate()
        keepAliveTimer = nil
        
        webSocketTask?.cancel(with: .normalClosure, reason: nil)
        
        for (id, pc) in peerConnections {
            LogStore.log("üõë Closing PC for \(getName(for: id))", type: .net)
            pc.close()
        }
        peerConnections.removeAll()
        roster.removeAll()
        
        localAudioTrack?.isEnabled = false
        localAudioTrack = nil
        
        isConnected = false
        activePeerCount = 0
        connectionStatus = "Disconnected"
    }

    private func listenSocket() {
        webSocketTask?.receive { [weak self] result in
            guard let self = self else { return }
            switch result {
            case .failure(let error):
                LogStore.log("‚ùå WS Error: \(error.localizedDescription)", type: .error)
                DispatchQueue.main.async {
                    if !self.isIntentionalDisconnect {
                        self.connectionStatus = "Signal Lost"
                        self.scheduleReconnect()
                    }
                }
            case .success(let message):
                if case .string(let text) = message {
                    self.handleSignal(text)
                }
                self.listenSocket()
            }
        }
    }
    
    private func scheduleReconnect() {
        if reconnectWorkItem != nil { return }
        
        LogStore.log("‚ö†Ô∏è Connection Lost. Retrying in 5s...", type: .warning)
        
        let workItem = DispatchWorkItem { [weak self] in
            guard let self = self else { return }
            self.reconnectWorkItem = nil
            
            if !self.isIntentionalDisconnect {
                Task {
                    LogStore.log("üîÑ Attempting Reconnection...", type: .net)
                    await self.connect(server: self.savedServerURL, room: self.savedRoomName, name: self.savedUserName)
                }
            }
        }
        
        self.reconnectWorkItem = workItem
        DispatchQueue.main.asyncAfter(deadline: .now() + 5.0, execute: workItem)
    }

    private func handleSignal(_ json: String) {
        guard let data = json.data(using: .utf8),
              let msg = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
              let type = msg["type"] as? String else { return }
        
        let senderId = msg["id"] as? String
        
        if senderId == self.myId && type != "roster-update" { return }

        Task { @MainActor in
            switch type {
            case "roster-update":
                if let raw = msg["roster"] as? [[String: Any]] { self.syncFullRoster(raw) }
                
            case "answer":
                if let sdp = msg["sdp"] as? String, let originId = senderId {
                    LogStore.log("üì© Received ANSWER from \(self.getName(for: originId))", type: .net)
                    self.handleRemoteAnswer(sdpString: sdp, originId: originId)
                }
                
            case "candidate":
                if let sdp = msg["candidate"] as? String,
                   let idx = msg["sdpMLineIndex"] as? Int32,
                   let mid = msg["sdpMid"] as? String,
                   let originId = senderId {
                    self.handleRemoteCandidate(sdp: sdp, idx: idx, mid: mid, originId: originId)
                }
            default: break
            }
        }
    }
    
    private func syncFullRoster(_ raw: [[String: Any]]) {
        // [FIX] Deduplication using Dictionary to prevent double entries
        var uniqueUsers: [String: PeerUser] = [:]

        // 1. Ensure 'Me' is preserved if I'm already in the roster
        if let me = self.roster.first(where: { $0.id == self.myId }) {
            uniqueUsers[self.myId] = me
        }
        
        // 2. Process incoming raw roster
        for item in raw {
            guard let uid = item["id"] as? String, uid != self.myId else { continue }
            
            var user = PeerUser(
                id: uid,
                name: item["name"] as? String ?? "Unknown",
                role: item["role"] as? String ?? "receiver",
                isBroadcasting: item["isBroadcasting"] as? Bool ?? false
            )
            
            // Preserve existing local state (ICE connection)
            if let existing = self.roster.first(where: { $0.id == uid }) {
                user.connectionState = existing.connectionState
            }
            
            // Overwrite ensures we only keep the latest version of this ID
            uniqueUsers[uid] = user
            
            // Check for new peers to call
            if self.peerConnections[uid] == nil {
                LogStore.log("üìû Found New Peer: \(user.name). Initiating Call...", type: .net)
                self.startCall(targetId: uid)
            }
        }
        
        // 3. Convert back to array and sort
        self.roster = Array(uniqueUsers.values).sorted(by: { $0.role == "duplex" ? true : $0.name < $1.name })
    }
    
    private func getOrCreatePeerConnection(for targetId: String) -> RTCPeerConnection {
        if let existing = peerConnections[targetId] { return existing }
        
        LogStore.log("üõ† Creating New PeerConnection for \(getName(for: targetId))", type: .info)
        
        let config = RTCConfiguration()
        config.iceServers = [RTCIceServer(urlStrings: ["stun:stun.l.google.com:19302"])]
        config.sdpSemantics = .unifiedPlan
        
        guard let pc = peerConnectionFactory.peerConnection(with: config, constraints: mediaConstraints, delegate: self) else {
            fatalError("PC Factory Failed")
        }
        
        if let track = self.localAudioTrack {
            pc.add(track, streamIds: ["stream-\(targetId)"])
            LogStore.log("‚ûï Local Track Added to PC (\(getName(for: targetId)))", type: .info)
        }
        
        peerConnections[targetId] = pc
        return pc
    }
    
    func startCall(targetId: String) {
        let pc = getOrCreatePeerConnection(for: targetId)
        let name = getName(for: targetId)
        
        LogStore.log("üì§ Creating OFFER for \(name)...", type: .info)
        
        pc.offer(for: mediaConstraints) { [weak self] sdp, error in
            guard let self = self else { return }
            
            guard let sdp = sdp else {
                LogStore.log("‚ùå Created Offer was nil: \(error?.localizedDescription ?? "Unknown")", type: .error)
                return
            }
            
            let tuned = WebRTCConfig.configureAudio(in: sdp, quality: .lossless)
            
            pc.setLocalDescription(tuned) { error in
                if error == nil {
                    LogStore.log("‚úÖ Offer Ready. Sending to \(name)", type: .info)
                    self.sendSignalingMessage(type: "offer", sdp: tuned, targetId: targetId)
                } else {
                    LogStore.log("‚ùå Set Local Description Failed", type: .error)
                }
            }
        }
    }
    
    func handleRemoteAnswer(sdpString: String, originId: String) {
        guard let pc = peerConnections[originId] else { return }
        let name = getName(for: originId)
        
        LogStore.log("üì• Applying Remote Answer from \(name)", type: .info)
        
        pc.setRemoteDescription(RTCSessionDescription(type: .answer, sdp: sdpString)) { [weak self] error in
            if error == nil {
                LogStore.log("‚úÖ Negotiated with \(name)", type: .success)
                self?.flushIceCandidates(for: originId, pc: pc)
            } else {
                LogStore.log("‚ùå Set Remote Description Failed", type: .error)
            }
        }
    }
    
    func handleRemoteCandidate(sdp: String, idx: Int32, mid: String, originId: String) {
        let c = RTCIceCandidate(sdp: sdp, sdpMLineIndex: idx, sdpMid: mid)
        if let pc = peerConnections[originId] {
            pc.add(c)
        } else {
            pendingIceCandidates[originId, default: []].append(c)
        }
    }
    
    private func flushIceCandidates(for targetId: String, pc: RTCPeerConnection) {
        if let list = pendingIceCandidates[targetId] {
            LogStore.log("üöø Flushing \(list.count) ICE Candidates for \(getName(for: targetId))", type: .info)
            for c in list { pc.add(c) }
        }
        pendingIceCandidates.removeValue(forKey: targetId)
    }

    private func sendSignalingMessage(type: String, sdp: RTCSessionDescription, targetId: String) {
        sendJson(["type": type, "sdp": sdp.sdp, "id": self.myId, "targetId": targetId])
    }
    
    private func broadcastStatus() {
        if activePeerCount == 0 { return }
        sendJson(["type": "status-update", "id": self.myId, "isBroadcasting": true, "isMicEnabled": false])
    }
    
    private func sendJson(_ msg: [String: Any]) {
        guard let task = webSocketTask, task.state == .running else { return }
        if let data = try? JSONSerialization.data(withJSONObject: msg),
           let str = String(data: data, encoding: .utf8) {
            task.send(.string(str)) { _ in }
        }
    }
    
    private func startStatsPoller() {
        let queue = DispatchQueue(label: "com.rewired.stats")
        statsSource = DispatchSource.makeTimerSource(queue: queue)
        statsSource?.schedule(deadline: .now(), repeating: 1.5)
        statsSource?.setEventHandler { [weak self] in self?.collectStats() }
        statsSource?.resume()
    }
    
    private func startKeepAlive() {
        DispatchQueue.main.async {
            self.keepAliveTimer = Timer.scheduledTimer(withTimeInterval: 5.0, repeats: true) { [weak self] _ in
                guard let self = self else { return }
                
                self.sendJson(["type": "get-roster"])
                
                var active = 0
                for (id, pc) in self.peerConnections {
                    let state = pc.iceConnectionState
                    
                    if let index = self.roster.firstIndex(where: { $0.id == id }) {
                        self.roster[index].connectionState = state
                    }
                    
                    if state == .connected || state == .completed {
                        active += 1
                    } else if state == .failed || state == .disconnected {
                        LogStore.log("‚ö†Ô∏è Peer \(self.getName(for: id)) Disconnected/Failed. Attempting ICE Restart.", type: .warning)
                        pc.restartIce()
                        self.startCall(targetId: id)
                    }
                }
                
                if active != self.activePeerCount {
                    self.activePeerCount = active
                    self.isConnected = active > 0
                    if active > 0 {
                        self.connectionStatus = "Stable (\(active) Peers)"
                        LogStore.log("üü¢ Session Active: \(active) Connected Peers", type: .success)
                    } else {
                        self.connectionStatus = "Waiting for Peers..."
                    }
                }
            }
        }
    }
    
    private func collectStats() {
        Task { @MainActor in
            var txTotal = 0
            for (_, pc) in self.peerConnections {
                pc.statistics { report in
                    for (_, stat) in report.statistics {
                        if stat.type == "outbound-rtp", let b = stat.values["bytesSent"] as? Int {
                            txTotal += b
                        }
                    }
                }
            }
            if txTotal > 0 {
                let kbps = Double(txTotal) / 1024.0
                self.txBitrate = String(format: "%.0f kbps", kbps)
            }
        }
    }
}

extension NwSessionCoordinator: RTCPeerConnectionDelegate {
    private func getPeerId(for pc: RTCPeerConnection) -> String {
        return peerConnections.first(where: { $0.value == pc })?.key ?? "Unknown"
    }

    func peerConnection(_ peerConnection: RTCPeerConnection, didAdd stream: RTCMediaStream) {
        let id = getPeerId(for: peerConnection)
        let name = getName(for: id)
        DispatchQueue.main.async {
            LogStore.log("üó£ [VOICE] Talkback started from \(name)", type: .signal)
        }
    }

    func peerConnection(_ peerConnection: RTCPeerConnection, didChange stateChanged: RTCSignalingState) {}
    func peerConnection(_ peerConnection: RTCPeerConnection, didRemove stream: RTCMediaStream) {}
    func peerConnectionShouldNegotiate(_ peerConnection: RTCPeerConnection) {}
    
    func peerConnection(_ peerConnection: RTCPeerConnection, didChange newState: RTCIceConnectionState) {
        let id = getPeerId(for: peerConnection)
        let name = getName(for: id)
        
        DispatchQueue.main.async {
            if let index = self.roster.firstIndex(where: { $0.id == id }) {
                self.roster[index].connectionState = newState
            }
            
            if newState == .connected {
                LogStore.log("‚úÖ üéµ [STUDIO] Uplink to \(name) Connected", type: .success)
            } else if newState == .failed {
                LogStore.log("‚ùå üéµ [STUDIO] Uplink to \(name) Failed", type: .error)
            } else if newState == .checking {
                LogStore.log("üîÑ üéµ [STUDIO] Uplink Negotiating with \(name)...", type: .net)
            }
        }
    }
    
    func peerConnection(_ peerConnection: RTCPeerConnection, didChange newState: RTCIceGatheringState) {}
    
    func peerConnection(_ peerConnection: RTCPeerConnection, didGenerate candidate: RTCIceCandidate) {
        if let targetId = peerConnections.first(where: { $0.value == peerConnection })?.key {
            sendJson([
                "type": "candidate",
                "candidate": candidate.sdp,
                "sdpMLineIndex": candidate.sdpMLineIndex,
                "sdpMid": candidate.sdpMid ?? "",
                "id": self.myId,
                "targetId": targetId
            ])
        }
    }
    
    func peerConnection(_ peerConnection: RTCPeerConnection, didRemove candidates: [RTCIceCandidate]) {}
    func peerConnection(_ peerConnection: RTCPeerConnection, didOpen dataChannel: RTCDataChannel) {}
}
