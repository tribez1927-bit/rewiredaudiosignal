<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rewired Studio Monitor</title>
    <style>
        :root {
            --bg: #121212;
            --card-bg: #1e1e1e; 
            --input-bg: #2c2c2e;
            --accent: #2979ff;
            --accent-dim: rgba(41, 121, 255, 0.2);
            --danger: #ff3b30;
            --success: #00e676;
            --warn: #ff9500;
            --text-main: #ffffff;
            --text-sub: #a1a1aa;
            --border: #333;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            margin: 0;
            padding: 24px 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .app-container {
            width: 100%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* --- HEADER PILL --- */
        .status-pill {
            align-self: center;
            background: var(--input-bg);
            padding: 10px 20px;
            border-radius: 30px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            border: 1px solid var(--border);
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            margin-bottom: 10px;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
            transition: background 0.3s;
        }
        .status-dot.on {
            background: var(--success);
            box-shadow: 0 0 10px var(--success);
            animation: pulse 2s infinite;
        }
        .status-dot.warn {
            background: var(--warn);
            box-shadow: 0 0 10px var(--warn);
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .status-text {
            font-size: 0.85rem;
            font-weight: 700;
            letter-spacing: 0.5px;
            color: var(--text-main);
        }
        .status-bitrate {
            font-family: monospace;
            font-size: 0.75rem;
            color: var(--text-sub);
            border-left: 1px solid #555;
            padding-left: 12px;
        }
        .status-quality {
            font-size: 0.7rem;
            padding: 2px 8px;
            border-radius: 8px;
            font-weight: 600;
        }
        .status-quality.excellent { background: rgba(0, 230, 118, 0.2); color: var(--success); }
        .status-quality.good { background: rgba(41, 121, 255, 0.2); color: var(--accent); }
        .status-quality.poor { background: rgba(255, 149, 0, 0.2); color: var(--warn); }

        /* Connected as text */
        .connected-as-text {
            align-self: center;
            font-size: 0.85rem;
            font-weight: 700;
            letter-spacing: 0.5px;
            color: var(--text-sub);
            text-align: center;
            margin-top: -10px;
            margin-bottom: 10px;
        }
        #connected-as-name {
            color: var(--text-main);
        }

        /* --- CARDS --- */
        .card {
            background: var(--card-bg);
            border-radius: 28px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 20px;
            transition: all 0.3s ease;
        }

        .card-header {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-main);
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* --- INPUTS --- */
        .input-group { display: flex; flex-direction: column; gap: 12px; }
        .input-group.hidden { display: none; }
        
        input {
            background: var(--input-bg);
            border: 1px solid transparent;
            color: white;
            padding: 16px;
            border-radius: 16px;
            font-size: 1rem;
            outline: none;
            transition: all 0.2s;
        }
        input:focus { border-color: var(--accent); background: #333; }

        /* --- MAIN BUTTON --- */
        .btn-connect {
            background: var(--accent);
            color: white;
            border: none;
            padding: 18px;
            border-radius: 18px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            width: 100%;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 20px rgba(41, 121, 255, 0.4);
        }
        .btn-connect:active { transform: scale(0.98); }
        .btn-connect:disabled { opacity: 0.5; cursor: not-allowed; }

        /* --- FLOATING DISCONNECT PANEL --- */
        .disconnect-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid var(--border);
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            transform: translateY(calc(100% - 20px));
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .disconnect-panel.expanded {
            transform: translateY(0);
        }
        
        .drag-handle {
            padding: 8px 0 12px 0;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
            user-select: none;
        }
        
        .drag-handle-bar {
            width: 40px;
            height: 4px;
            background: var(--text-sub);
            border-radius: 2px;
            transition: all 0.2s;
        }
        
        .drag-handle:hover .drag-handle-bar {
            background: var(--text-main);
            width: 50px;
        }
        
        .btn-disconnect {
            background: var(--danger);
            color: white;
            border: none;
            padding: 18px;
            margin: 0 16px 20px 16px;
            border-radius: 18px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            width: calc(100% - 32px);
            max-width: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 20px rgba(255, 59, 48, 0.4);
            margin-left: auto;
            margin-right: auto;
        }
        
        .btn-disconnect:active {
            transform: scale(0.98);
        }
        
        .btn-disconnect svg {
            width: 20px;
            height: 20px;
        }

        /* --- AUDIO CONTROLS --- */
        .audio-controls {
            display: flex;
            flex-direction: column;
            gap: 24px;
            margin-top: 8px;
        }

        /* Slider */
        .slider-row { display: flex; align-items: center; gap: 12px; }
        .voice-slider-row { margin-top: 8px; }

        .slider-btn {
            width: 36px; height: 36px; min-width: 36px; border-radius: 50%;
            background: var(--input-bg); border: none; color: var(--text-sub);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative; padding: 0;
        }
        .slider-btn svg { width: 18px; height: 18px; fill: currentColor; }
        .slider-btn:hover { background: #3a3a3c; }
        .slider-btn.active { background: var(--accent); color: white; box-shadow: 0 2px 8px var(--accent-dim); }
        .slider-btn.muted-state { background: var(--input-bg); color: var(--danger); box-shadow: none; border: 1px solid var(--danger); }
        .slider-btn.repairing { background: var(--warn); color: black; }
        .slider-btn.repairing::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 2px solid var(--warn);
            animation: ripple 1s infinite;
        }
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            padding: 0; margin: 0; border: 0;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 6px; cursor: pointer;
            background: #444; border-radius: 3px;
        }
        input[type=range]::-webkit-slider-thumb {
            height: 22px; width: 22px; border-radius: 50%;
            background: var(--accent); cursor: pointer;
            -webkit-appearance: none; margin-top: -8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            transition: transform 0.1s;
        }
        input[type=range]::-webkit-slider-thumb:active { transform: scale(1.2); }

        /* Toggles */
        
        @keyframes ripple {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.3); opacity: 0; }
        }

        /* --- ROSTER --- */
        #roster-card { display: none; }
        .roster-list { display: flex; flex-direction: column; gap: 10px; }
        
        .roster-item {
            display: flex; align-items: center; justify-content: space-between;
            background: rgba(255,255,255,0.03); padding: 14px 18px; border-radius: 16px;
            transition: background 0.2s;
        }
        .roster-item:hover { background: rgba(255,255,255,0.05); }
        .roster-left { display: flex; align-items: center; gap: 14px; }
        .roster-name { font-weight: 600; font-size: 0.95rem; color: #eee; }
        .roster-name-highlight {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--warn);
        }
        .roster-status {
            font-size: 0.7rem;
            color: var(--text-sub);
            margin-left: 8px;
            padding: 2px 6px;
            border-radius: 6px;
            background: rgba(255,255,255,0.05);
        }
        .roster-status.connecting { color: var(--warn); }
        .roster-status.connected { color: var(--success); }
        .roster-status.failed { color: var(--danger); }
        
        /* Icons & Meters */
        .icon-box { width: 22px; height: 22px; display: flex; align-items: center; justify-content: center; color: #555; }
        .icon-box svg { width: 100%; height: 100%; fill: currentColor; }
        .icon-box.sender { color: var(--accent); }
        .icon-box.active { color: var(--success); }
        .icon-box.inactive { color: var(--text-sub); }

        /* General Meters */
        .mini-meters { display: flex; gap: 3px; height: 14px; align-items: flex-end; }
        .mini-meter-col { width: 4px; height: 100%; background: #333; border-radius: 2px; position: relative; overflow: hidden; }
        .mini-meter-fill { width: 100%; position: absolute; bottom: 0; background: var(--success); height: 0%; transition: height 0.08s ease-out; }
        
        /* Roster Specific Meter Alignment */
        .meter-column-fixed { width: 22px; height: 22px; display: flex; justify-content: center; align-items: center; }

        /* Horizontal roster meters */
        .roster-meters-horizontal { flex: 1; display: flex; flex-direction: column; gap: 2px; margin: 0 12px; min-width: 40px; }
        .h-meter-row { height: 4px; background: #333; border-radius: 2px; position: relative; overflow: hidden; width: 100%; }
        .h-meter-fill { height: 100%; position: absolute; left: 0; background: var(--success); width: 0%; transition: width 0.08s ease-out; }

        /* --- CONSOLE --- */
        #console-card { display: none; flex: 1; min-height: 0; }
        #console {
            background: #0b0b0b; border-radius: 16px; padding: 16px;
            font-family: 'Menlo', 'Monaco', monospace; font-size: 0.7rem; color: #777;
            height: 180px; overflow-y: auto; border: 1px solid #222;
        }
        #console::-webkit-scrollbar { width: 6px; }
        #console::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
        .log-err { color: var(--danger); }
        .log-mic { color: #d63aff; }
        .log-vol { color: var(--success); }
        .log-sys { color: var(--accent); }
        .log-warn { color: var(--warn); }

        .hidden { display: none !important; }
        
        /* Network quality indicator */
        .network-stats {
            display: flex;
            gap: 10px;
            font-size: 0.6rem;
            color: var(--text-sub);
            justify-content: center;
            width: 100%;
            padding: 0;
            margin-top: -4px;
        }
        .network-stat {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .network-stat-label { font-weight: 600; }
        .network-stat-value { font-family: monospace; }
    </style>
</head>
<body>

<div class="app-container">
    
    <div class="status-pill">
        <div id="status-dot" class="status-dot"></div>
        <span id="status-text" class="status-text">READY</span>
        <span id="bitrate" class="status-bitrate" style="display:none">0 kbps</span>
        <span id="quality-badge" class="status-quality" style="display:none">Good</span>
        
        <div class="network-stats" id="network-stats" style="display:none">
            <div class="network-stat">
                <span class="network-stat-label">Latency</span>
                <span class="network-stat-value" id="stat-latency">--</span>
            </div>
            <div class="network-stat">
                <span class="network-stat-label">Loss</span>
                <span class="network-stat-value" id="stat-loss">--</span>
            </div>
            <div class="network-stat">
                <span class="network-stat-label">Jitter</span>
                <span class="network-stat-value" id="stat-jitter">--</span>
            </div>
        </div>
    </div>

    <div id="connected-as" class="connected-as-text" style="display:none">
        Connected as <span id="connected-as-name"></span>
    </div>

    <div class="card">
        <div id="setup-panel" class="input-group">
            <input id="room" value="studio1" placeholder="Room Name" aria-label="Room Name">
            <input id="user" placeholder="Your Name" aria-label="Your Name">
        </div>

        <button id="btn-connect" class="btn-connect" aria-label="Connect to studio">Listen Live</button>

        <div id="controls-panel" class="audio-controls hidden">
            <div class="slider-row">
                <svg width="18" height="18" fill="#666" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 9v6h4l5 5V4L7 9H3z"/></svg>
                <input type="range" id="vol-slider" min="0" max="1" step="0.01" value="0.8" aria-label="Volume">
                <button id="btn-mute" class="slider-btn active" aria-label="Toggle mute">
                    <svg id="icon-vol" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 9v6h4l5 5V4L7 9H3zM16.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
                    <svg id="icon-mute" viewBox="0 0 24 24" style="display:none" aria-hidden="true"><path d="M19 12c0 1.72-1.02 3.22-2.5 4v2.15c2.34-.99 4-3.32 4-6.15 0-2.83-1.66-5.16-4-6.15V8c1.48.78 2.5 2.28 2.5 4zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73 4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>
                </button>
            </div>

            <div class="slider-row voice-slider-row">
                <svg width="18" height="18" fill="#666" viewBox="0 0 24 24" aria-hidden="true"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
                <input type="range" id="voice-vol-slider" min="0" max="1" step="0.01" value="0.8" aria-label="Voice Volume">
                <button id="btn-talk" class="slider-btn" aria-label="Push to talk">
                    <svg id="icon-talk-off" viewBox="0 0 24 24" aria-hidden="true"><path d="M19 11h-1.7c0 .74-.16 1.43-.43 2.05l1.23 1.23c.56-.98.9-2.09.9-3.28zm-4.02.17c0-.06.02-.11.02-.17V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>
                    <svg id="icon-talk-on" viewBox="0 0 24 24" style="display:none;" aria-hidden="true"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>
                    <svg id="icon-repair" viewBox="0 0 24 24" style="display:none;" aria-hidden="true"><path d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"/></svg>
                </button>
            </div>
            
        </div>
    </div>

    <div id="roster-card" class="card">
        <div class="card-header">
            Participants
            <span id="participant-count" style="font-size: 0.8rem; color: var(--text-sub); font-weight: 400;"></span>
        </div>
        <div id="roster-list" class="roster-list"></div>
    </div>

    <div id="console-card" class="card">
        <div class="card-header">
            Console
            <button id="btn-clear-console" style="background: none; border: none; color: var(--text-sub); cursor: pointer; font-size: 0.8rem; padding: 4px 8px;" aria-label="Clear console">Clear</button>
        </div>
        <div id="console"></div>
    </div>

</div>

<!-- Floating Disconnect Panel -->
<div id="disconnect-panel" class="disconnect-panel" style="display:none">
    <div id="drag-handle" class="drag-handle">
        <div class="drag-handle-bar"></div>
    </div>
    <button id="btn-disconnect" class="btn-disconnect" aria-label="Disconnect from studio">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
        </svg>
        Disconnect
    </button>
</div>

<div id="voice-container" style="display:none"></div>

<script>
(function() {
    'use strict';
    
    // Configuration
    const CONFIG = {
        WS_URL: window.location.origin.replace(/^http/, 'ws'),
        MAX_RECONNECT_ATTEMPTS: 10,
        RECONNECT_BASE_DELAY: 1000,
        RECONNECT_MAX_DELAY: 30000,
        ICE_RESTART_DELAY: 2000,
        PEER_INIT_DELAY: 500,
        VERIFICATION_TIMEOUT: 4000,
        ICE_GATHERING_TIMEOUT: 10000,
        STATS_INTERVAL: 1000,
        METER_UPDATE_INTERVAL: 60,
        PEER_HEALTH_CHECK_INTERVAL: 5000,
        CANDIDATE_TIMEOUT: 10000,
        ICE_SERVERS: [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:stun1.l.google.com:19302" },
            // Add TURN servers here for production:
            // { urls: "turn:your-turn-server.com:3478", username: "user", credential: "pass" }
        ],
        RTC_CONFIG: {
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            iceCandidatePoolSize: 10
        },
        AUDIO_CONSTRAINTS: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            sampleRate: 48000,
            channelCount: 2
        },
        SDP_OPTIMIZATION: {
            stereo: true,
            maxBitrate: 510000,
            ptime: 10,
            cbr: true,
            dtx: false
        }
    };

    // State Management
    const state = {
        myId: 'rx-' + Math.floor(Math.random() * 10000),
        ws: null,
        audioCtx: null,
        studioPC: null,
        masterGain: null,
        studioGain: null,
        voiceGain: null,
        statsInterval: null,
        healthCheckInterval: null,
        meterIntervals: new Map(),
        voicePeerConnections: new Map(),
        pendingPeerConnections: new Set(),
        isConnected: false,
        isMuted: false,
        isTalking: false,
        isRepairing: false,
        localVoiceStream: null,
        broadcasterId: null,
        currentRoomName: "",
        myUserName: "",
        lastVolume: 0.8,
        lastVoiceVolume: 0.8,
        myIPs: new Set(),
        senderIPs: new Set(),
        nameWasEmpty: false,
        verificationTimer: null,
        hasRenamedToMonitor: false,
        currentRoster: [],
        reconnectAttempts: 0,
        reconnectTimer: null,
        connectionQuality: { bitrate: 0, latency: 0, packetLoss: 0, jitter: 0 }
    };

    // UI Element References
    const ui = {
        statusText: document.getElementById('status-text'),
        statusDot: document.getElementById('status-dot'),
        bitrateEl: document.getElementById('bitrate'),
        qualityBadge: document.getElementById('quality-badge'),
        connectedAs: document.getElementById('connected-as'),
        connectedAsName: document.getElementById('connected-as-name'),
        btnConnect: document.getElementById('btn-connect'),
        btnDisconnect: document.getElementById('btn-disconnect'),
        disconnectPanel: document.getElementById('disconnect-panel'),
        dragHandle: document.getElementById('drag-handle'),
        btnMute: document.getElementById('btn-mute'),
        btnTalk: document.getElementById('btn-talk'),
        volSlider: document.getElementById('vol-slider'),
        voiceVolSlider: document.getElementById('voice-vol-slider'),
        logEl: document.getElementById('console'),
        btnClearConsole: document.getElementById('btn-clear-console'),
        setupPanel: document.getElementById('setup-panel'),
        controlsPanel: document.getElementById('controls-panel'),
        rosterCard: document.getElementById('roster-card'),
        rosterList: document.getElementById('roster-list'),
        participantCount: document.getElementById('participant-count'),
        consoleCard: document.getElementById('console-card'),
        networkStats: document.getElementById('network-stats'),
        roomInput: document.getElementById('room'),
        userInput: document.getElementById('user')
    };

    // SVG Icons
    const ICONS = {
        MIC: `<svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>`,
        HEADPHONES: `<svg viewBox="0 0 24 24"><path d="M12 3c-4.97 0-9 4.03-9 9v7c0 1.1.9 2 2 2h4v-8H5v-1c0-3.87 3.13-7 7-7s7 3.13 7 7v1h-4v8h4c1.1 0 2-.9 2-2v-7c0-4.97-4.03-9-9-9z"/></svg>`
    };

    // ===== UTILITY FUNCTIONS =====

    function log(msg, type = 'info') {
        const line = document.createElement('div');
        const time = new Date().toLocaleTimeString();
        line.innerText = `[${time}] ${msg}`;
        
        const typeMap = {
            mic: 'log-mic',
            vol: 'log-vol',
            err: 'log-err',
            success: 'log-sys',
            warn: 'log-warn'
        };
        
        if (typeMap[type]) {
            line.className = typeMap[type];
        }
        
        ui.logEl.prepend(line);
        
        // Limit console to 100 entries
        while (ui.logEl.children.length > 100) {
            ui.logEl.removeChild(ui.logEl.lastChild);
        }
    }

    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    function getName(id) {
        if (id === state.myId) return state.myUserName;
        const user = state.currentRoster.find(x => x.id === id);
        return user ? user.name : id.substring(0, 5);
    }

    function getConnectionState(peerId) {
        const session = state.voicePeerConnections.get(peerId);
        if (!session) return 'not-connected';
        return session.pc.connectionState;
    }

    // ===== AUDIO MANAGEMENT =====

    class AudioManager {
        static async initialize() {
            try {
                state.audioCtx = new (window.AudioContext || window.webkitAudioContext)({
                    latencyHint: 'interactive',
                    sampleRate: 48000
                });
                
                state.masterGain = state.audioCtx.createGain();
                state.masterGain.gain.value = 1.0;
                state.masterGain.connect(state.audioCtx.destination);

                state.studioGain = state.audioCtx.createGain();
                state.studioGain.gain.value = state.lastVolume;
                state.studioGain.connect(state.masterGain);

                state.voiceGain = state.audioCtx.createGain();
                state.voiceGain.gain.value = state.lastVoiceVolume;
                state.voiceGain.connect(state.masterGain);
                
                await state.audioCtx.resume();
                log("üéµ Audio Context Ready", "success");
                return true;
            } catch (e) {
                log(`Audio Init Failed: ${e.message}`, "err");
                return false;
            }
        }

        static async requestMicrophone() {
            try {
                log("üéô Requesting Microphone...", "mic");
                state.localVoiceStream = await navigator.mediaDevices.getUserMedia({
                    audio: CONFIG.AUDIO_CONSTRAINTS
                });
                
                // Start muted
                state.localVoiceStream.getAudioTracks().forEach(t => t.enabled = false);
                log("üéô Microphone Ready (Muted)", "mic");
                
                this.monitorAndRouteAudio(state.localVoiceStream, "Local Mic", state.myId, false);
                return true;
            } catch (e) {
                log(`üö´ Microphone Access Denied: ${e.message}`, "err");
                state.localVoiceStream = null;
                return false;
            }
        }

        static monitorAndRouteAudio(stream, label, rosterId, shouldRoute = true, targetGain = null) {
            if (!state.audioCtx || !state.masterGain) return;

            try {
                const src = state.audioCtx.createMediaStreamSource(stream);
                const analyzer = state.audioCtx.createAnalyser();
                analyzer.fftSize = 256;
                analyzer.smoothingTimeConstant = 0.8;

                src.connect(analyzer);

                // Route to speakers (but not local mic to avoid feedback)
                if (shouldRoute) {
                    analyzer.connect(targetGain || state.masterGain);
                }

                const data = new Uint8Array(analyzer.frequencyBinCount);
                let frameCount = 0;
                
                const updateMeters = () => {
                    if (!stream.active) {
                        state.meterIntervals.delete(rosterId);
                        return;
                    }
                    
                    analyzer.getByteFrequencyData(data);
                    let sum = 0;
                    for (let i = 0; i < data.length; i++) sum += data[i];
                    const avg = sum / data.length;
                    
                    // Update roster meters (logarithmic scale)
                    if (rosterId) {
                        const fillL = document.getElementById(`ml-${rosterId}`);
                        const fillR = document.getElementById(`mr-${rosterId}`);
                        if (fillL && fillR) {
                            const dB = avg > 0 ? 20 * Math.log10(avg / 255) : -60;
                            const percentage = Math.min(100, Math.max(0, ((dB + 60) / 60) * 100));
                            fillL.style.width = percentage + "%";
                            fillR.style.width = percentage + "%";
                        }
                    }

                    // Occasional logging (not for studio to reduce spam)
                    frameCount++;
                    if (!label.includes("Studio") && avg > 25 && frameCount % 50 === 0) {
                        const tag = label.includes("Mic") ? "[MIC]" : "[VOICE]";
                        const logLabel = rosterId ? getName(rosterId) : label;
                        log(`${tag} ${logLabel}: ${avg.toFixed(0)}`, "vol");
                    }
                    
                    requestAnimationFrame(updateMeters);
                };
                
                state.meterIntervals.set(rosterId, updateMeters);
                updateMeters();
            } catch (e) {
                log(`Route Error: ${e.message}`, "err");
            }
        }

        static setVolume(value, immediate = false) {
            if (!state.studioGain) return;

            if (immediate) {
                state.studioGain.gain.value = value;
            } else {
                state.studioGain.gain.setTargetAtTime(value, state.audioCtx.currentTime, 0.05);
            }
        }

        static setVoiceVolume(value, immediate = false) {
            if (!state.voiceGain) return;
            if (immediate) {
                state.voiceGain.gain.value = value;
            } else {
                state.voiceGain.gain.setTargetAtTime(value, state.audioCtx.currentTime, 0.05);
            }
        }

        static cleanup() {
            // Stop all meter intervals
            state.meterIntervals.forEach(interval => interval());
            state.meterIntervals.clear();
            
            // Stop local stream
            if (state.localVoiceStream) {
                state.localVoiceStream.getTracks().forEach(t => t.stop());
                state.localVoiceStream = null;
            }
            
            // Clear audio context
            if (state.audioCtx) {
                state.audioCtx.close();
                state.audioCtx = null;
            }
            
            state.masterGain = null;
            state.studioGain = null;
            state.voiceGain = null;
        }
    }

    // ===== PEER CONNECTION MANAGEMENT =====

    class PeerConnectionManager {
        static createVoicePeer(peerId) {
            if (state.voicePeerConnections.has(peerId)) {
                return state.voicePeerConnections.get(peerId);
            }

            const config = {
                iceServers: CONFIG.ICE_SERVERS,
                ...CONFIG.RTC_CONFIG
            };

            const pc = new RTCPeerConnection(config);
            const session = {
                pc: pc,
                candidates: [],
                state: 'initializing',
                lastStateChange: Date.now(),
                iceRestartCount: 0
            };

            // Add local tracks (addTrack implicitly creates a sendrecv transceiver)
            if (state.localVoiceStream) {
                state.localVoiceStream.getTracks().forEach(track => {
                    pc.addTrack(track, state.localVoiceStream);
                });
            } else {
                // No mic yet; create a recvonly transceiver so we can still receive
                pc.addTransceiver('audio', { direction: 'recvonly' });
            }

            // Event handlers
            pc.ontrack = (e) => {
                log(`üó£ [VOICE] Audio from ${getName(peerId)}`, "success");
                AudioManager.monitorAndRouteAudio(e.streams[0], `Voice ${peerId.substring(0, 4)}`, peerId, true, state.voiceGain);
            };

            pc.onicecandidate = (e) => {
                if (e.candidate) {
                    this.handleLocalIceCandidate(e.candidate, peerId);
                    
                    if (state.ws && state.ws.readyState === WebSocket.OPEN) {
                        state.ws.send(JSON.stringify({
                            type: 'candidate',
                            ...e.candidate.toJSON(),
                            id: state.myId,
                            targetId: peerId
                        }));
                    }
                }
            };

            pc.oniceconnectionstatechange = () => {
                this.handleIceStateChange(peerId, pc.iceConnectionState);
            };

            pc.onconnectionstatechange = () => {
                this.handleConnectionStateChange(peerId, pc.connectionState);
            };

            pc.onicegatheringstatechange = () => {
                log(`üó£ [ICE] Gathering ${pc.iceGatheringState} for ${getName(peerId)}`, "info");
                
                if (pc.iceGatheringState === 'gathering') {
                    // Set timeout for gathering
                    session.iceGatheringTimeout = setTimeout(() => {
                        if (pc.iceGatheringState === 'gathering') {
                            log(`üó£ [ICE] Gathering timeout for ${getName(peerId)}`, "warn");
                        }
                    }, CONFIG.ICE_GATHERING_TIMEOUT);
                } else if (pc.iceGatheringState === 'complete') {
                    if (session.iceGatheringTimeout) {
                        clearTimeout(session.iceGatheringTimeout);
                        session.iceGatheringTimeout = null;
                    }
                }
            };

            state.voicePeerConnections.set(peerId, session);
            log(`üó£ Created peer connection for ${getName(peerId)}`, "info");
            
            return session;
        }

        static handleLocalIceCandidate(candidate, peerId) {
            const parts = candidate.candidate.split(' ');
            if (parts.length > 4) {
                const ip = parts[4];
                if (!ip.includes(':') && parts[7] === 'host') {
                    if (!state.myIPs.has(ip)) {
                        state.myIPs.add(ip);
                        log(`üîç [MY IP] ${ip}`, "info");
                    }
                    IdentityManager.checkIPMatch();
                }
            }
        }

        static handleIceStateChange(peerId, iceState) {
            log(`üó£ [ICE] ${getName(peerId)}: ${iceState}`, iceState === 'failed' ? 'err' : 'info');
            
            const session = state.voicePeerConnections.get(peerId);
            if (!session) return;

            if (iceState === 'failed' || iceState === 'disconnected') {
                // Auto-repair with backoff
                if (session.iceRestartCount < 3) {
                    setTimeout(() => {
                        this.restartIce(peerId);
                    }, CONFIG.ICE_RESTART_DELAY * (session.iceRestartCount + 1));
                } else {
                    log(`üó£ [VOICE] Max restart attempts reached for ${getName(peerId)}`, "err");
                    state.isRepairing = true;
                    UIManager.updateButtons();
                }
            } else if (iceState === 'connected' || iceState === 'completed') {
                session.iceRestartCount = 0;
                state.isRepairing = false;
                UIManager.updateButtons();
            }
            
            UIManager.updateRosterStatus(peerId, iceState);
        }

        static handleConnectionStateChange(peerId, connState) {
            log(`üó£ [CONN] ${getName(peerId)}: ${connState}`, connState === 'connected' ? 'success' : 'info');
            
            const session = state.voicePeerConnections.get(peerId);
            if (session) {
                session.state = connState;
                session.lastStateChange = Date.now();
            }
            
            UIManager.updateRosterStatus(peerId, connState);
        }

        static async restartIce(peerId) {
            const session = state.voicePeerConnections.get(peerId);
            if (!session) return;

            try {
                log(`üîß [REPAIR] Restarting ICE for ${getName(peerId)}`, "warn");
                session.iceRestartCount++;
                
                const offer = await session.pc.createOffer({ iceRestart: true });
                await session.pc.setLocalDescription(offer);
                
                if (state.ws && state.ws.readyState === WebSocket.OPEN) {
                    state.ws.send(JSON.stringify({
                        type: 'offer',
                        sdp: offer.sdp,
                        id: state.myId,
                        targetId: peerId,
                        iceRestart: true
                    }));
                }
            } catch (e) {
                log(`üîß [REPAIR] Failed for ${getName(peerId)}: ${e.message}`, "err");
            }
        }

        static async handleOffer(msg) {
            const peerId = msg.id;
            const session = this.createVoicePeer(peerId);
            const pc = session.pc;

            try {
                // Handle glare (simultaneous offers)
                if (pc.signalingState !== 'stable') {
                    if (state.myId < peerId) {
                        // Lower ID wins, rollback local offer
                        log(`üó£ [GLARE] Rolling back for ${getName(peerId)}`, "warn");
                        await pc.setLocalDescription({ type: 'rollback' });
                    } else {
                        // Higher ID waits
                        log(`üó£ [GLARE] Deferring offer from ${getName(peerId)}`, "warn");
                        setTimeout(() => this.handleOffer(msg), 500);
                        return;
                    }
                }

                await pc.setRemoteDescription(new RTCSessionDescription({
                    type: 'offer',
                    sdp: msg.sdp
                }));

                // Process queued candidates after remote description is set
                log(`üó£ [SDP] Processing ${session.candidates.length} queued candidates`, "info");
                while (session.candidates.length > 0) {
                    const item = session.candidates.shift();
                    try {
                        await pc.addIceCandidate(item.candidate);
                    } catch (e) {
                        log(`üó£ [ICE] Failed to add queued candidate: ${e.message}`, "warn");
                    }
                }

                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                if (state.ws && state.ws.readyState === WebSocket.OPEN) {
                    state.ws.send(JSON.stringify({
                        type: 'answer',
                        sdp: answer.sdp,
                        id: state.myId,
                        targetId: peerId
                    }));
                }

                log(`üó£ [SDP] Answer sent to ${getName(peerId)}`, "success");
            } catch (e) {
                log(`üó£ [SDP] Offer handling failed: ${e.message}`, "err");
            }
        }

        static async handleAnswer(msg) {
            const peerId = msg.id;
            const session = state.voicePeerConnections.get(peerId);
            
            if (!session) {
                log(`üó£ [SDP] No session for answer from ${getName(peerId)}`, "warn");
                return;
            }

            const pc = session.pc;

            try {
                if (pc.signalingState !== 'have-local-offer') {
                    log(`üó£ [SDP] Invalid state for answer: ${pc.signalingState}`, "warn");
                    return;
                }

                await pc.setRemoteDescription(new RTCSessionDescription({
                    type: 'answer',
                    sdp: msg.sdp
                }));

                // Process queued candidates after remote description is set
                log(`üó£ [SDP] Processing ${session.candidates.length} queued candidates`, "info");
                while (session.candidates.length > 0) {
                    const item = session.candidates.shift();
                    try {
                        await pc.addIceCandidate(item.candidate);
                    } catch (e) {
                        log(`üó£ [ICE] Failed to add queued candidate: ${e.message}`, "warn");
                    }
                }

                log(`üó£ [SDP] Answer processed from ${getName(peerId)}`, "success");
            } catch (e) {
                log(`üó£ [SDP] Answer handling failed: ${e.message}`, "err");
            }
        }

        static async handleCandidate(msg) {
            const peerId = msg.id;
            
            // Also collect sender IPs from voice peer candidates
            const parts = msg.candidate ? msg.candidate.split(' ') : [];
            if (parts.length > 4) {
                const ip = parts[4];
                if (!ip.includes(':') && parts[7] === 'host') {
                    if (!state.senderIPs.has(ip)) {
                        state.senderIPs.add(ip);
                        log(`üîç [SENDER IP] ${ip} (from ${getName(peerId)})`, "info");
                    }
                    IdentityManager.checkIPMatch();
                }
            }
            
            const session = state.voicePeerConnections.get(peerId);
            
            if (!session) {
                log(`üó£ [ICE] Candidate for unknown peer ${getName(peerId)}`, "warn");
                return;
            }

            const pc = session.pc;
            const candidate = new RTCIceCandidate(msg);

            try {
                if (pc.remoteDescription && pc.remoteDescription.type) {
                    await pc.addIceCandidate(candidate);
                } else {
                    // Queue candidates with timeout
                    session.candidates.push({
                        candidate,
                        timestamp: Date.now()
                    });
                    
                    // Clean up old candidates
                    setTimeout(() => {
                        session.candidates = session.candidates.filter(
                            c => Date.now() - c.timestamp < CONFIG.CANDIDATE_TIMEOUT
                        );
                    }, CONFIG.CANDIDATE_TIMEOUT);
                }
            } catch (e) {
                log(`üó£ [ICE] Candidate error: ${e.message}`, "err");
            }
        }

        static async initiateConnection(peerId) {
            if (state.pendingPeerConnections.has(peerId)) {
                return;
            }

            state.pendingPeerConnections.add(peerId);

            try {
                const session = this.createVoicePeer(peerId);
                
                // Wait for ICE gathering to start
                await new Promise(resolve => {
                    if (session.pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        const handler = () => {
                            if (session.pc.iceGatheringState !== 'new') {
                                session.pc.removeEventListener('icegatheringstatechange', handler);
                                resolve();
                            }
                        };
                        session.pc.addEventListener('icegatheringstatechange', handler);
                        // Timeout after 5 seconds
                        setTimeout(resolve, 5000);
                    }
                });
                
                const offer = await session.pc.createOffer();
                await session.pc.setLocalDescription(offer);

                if (state.ws && state.ws.readyState === WebSocket.OPEN) {
                    state.ws.send(JSON.stringify({
                        type: 'offer',
                        sdp: offer.sdp,
                        id: state.myId,
                        targetId: peerId
                    }));
                    
                    log(`üó£ [SDP] Offer sent to ${getName(peerId)}`, "info");
                } else {
                    log(`üó£ [SDP] Cannot send offer - signaling disconnected`, "err");
                    state.pendingPeerConnections.delete(peerId);
                }
            } catch (e) {
                log(`üó£ [SDP] Failed to create offer for ${getName(peerId)}: ${e.message}`, "err");
                state.pendingPeerConnections.delete(peerId);
            }
        }

        static closePeer(peerId) {
            const session = state.voicePeerConnections.get(peerId);
            if (session) {
                if (session.iceGatheringTimeout) {
                    clearTimeout(session.iceGatheringTimeout);
                }
                session.pc.close();
                state.voicePeerConnections.delete(peerId);
                state.meterIntervals.delete(peerId);
                log(`üó£ Closed connection to ${getName(peerId)}`, "info");
            }
        }

        static closeAll() {
            state.voicePeerConnections.forEach((session, peerId) => {
                if (session.iceGatheringTimeout) {
                    clearTimeout(session.iceGatheringTimeout);
                }
                session.pc.close();
            });
            state.voicePeerConnections.clear();
            state.pendingPeerConnections.clear();
            
            if (state.healthCheckInterval) {
                clearInterval(state.healthCheckInterval);
                state.healthCheckInterval = null;
            }
        }

        static startHealthMonitoring() {
            if (state.healthCheckInterval) {
                clearInterval(state.healthCheckInterval);
            }

            state.healthCheckInterval = setInterval(() => {
                state.voicePeerConnections.forEach((session, peerId) => {
                    const pc = session.pc;
                    const connState = pc.connectionState;
                    const iceState = pc.iceConnectionState;

                    // Check for stale connections
                    const timeSinceLastChange = Date.now() - session.lastStateChange;

                    if (connState === 'disconnected' && timeSinceLastChange > 10000) {
                        log(`üó£ [HEALTH] Stale connection detected for ${getName(peerId)}`, "warn");
                        this.restartIce(peerId);
                    } else if (connState === 'failed' && session.iceRestartCount === 0) {
                        log(`üó£ [HEALTH] Failed connection, attempting repair for ${getName(peerId)}`, "warn");
                        this.restartIce(peerId);
                    } else if (iceState === 'checking' && timeSinceLastChange > 15000) {
                        log(`üó£ [HEALTH] ICE stuck in checking state for ${getName(peerId)}`, "warn");
                        this.restartIce(peerId);
                    }
                });
            }, CONFIG.PEER_HEALTH_CHECK_INTERVAL);

            log(`üó£ [HEALTH] Monitoring started`, "info");
        }
    }

    // ===== STUDIO CONNECTION MANAGEMENT =====

    class StudioConnectionManager {
        static async handleOffer(msg) {
            try {
                // Close existing studio connection
                if (state.studioPC) {
                    state.studioPC.close();
                }

                const config = {
                    iceServers: CONFIG.ICE_SERVERS,
                    ...CONFIG.RTC_CONFIG
                };

                state.studioPC = new RTCPeerConnection(config);

                state.studioPC.ontrack = (e) => {
                    log("üéµ [STUDIO] Stream Active", "success");
                    AudioManager.monitorAndRouteAudio(e.streams[0], "Studio Stream", state.broadcasterId, true, state.studioGain);
                    this.startStats();
                };

                state.studioPC.onicecandidate = (e) => {
                    if (e.candidate) {
                        this.handleLocalIceCandidate(e.candidate);
                        
                        if (state.ws && state.ws.readyState === WebSocket.OPEN) {
                            state.ws.send(JSON.stringify({
                                type: 'candidate',
                                ...e.candidate.toJSON(),
                                id: state.myId,
                                targetId: msg.id
                            }));
                        }
                    }
                };

                state.studioPC.onconnectionstatechange = () => {
                    const connState = state.studioPC.connectionState;
                    log(`üéµ [STUDIO] Connection: ${connState}`, connState === 'connected' ? 'success' : 'info');
                    
                    if (connState === 'connected') {
                        UIManager.setUIState('connected');
                    } else if (['disconnected', 'failed', 'closed'].includes(connState)) {
                        log("üéµ [STUDIO] Stream Ended", "err");
                        if (state.statsInterval) {
                            clearInterval(state.statsInterval);
                            state.statsInterval = null;
                        }
                        UIManager.setUIState('disconnected');
                    }
                };

                await state.studioPC.setRemoteDescription(new RTCSessionDescription({
                    type: 'offer',
                    sdp: msg.sdp
                }));

                const answer = await state.studioPC.createAnswer();
                
                // Optimize SDP for high-quality audio
                answer.sdp = this.optimizeSDP(answer.sdp);
                
                await state.studioPC.setLocalDescription(answer);

                if (state.ws && state.ws.readyState === WebSocket.OPEN) {
                    state.ws.send(JSON.stringify({
                        type: 'answer',
                        sdp: answer.sdp,
                        id: state.myId,
                        targetId: msg.id
                    }));
                }

                log("üéµ [STUDIO] Answer sent", "success");
            } catch (e) {
                log(`üéµ [STUDIO] Offer handling failed: ${e.message}`, "err");
            }
        }

        static handleLocalIceCandidate(candidate) {
            const parts = candidate.candidate.split(' ');
            if (parts.length > 4) {
                const ip = parts[4];
                if (!ip.includes(':') && parts[7] === 'host') {
                    if (!state.senderIPs.has(ip)) {
                        state.senderIPs.add(ip);
                        log(`üîç [SENDER IP] ${ip}`, "info");
                    }
                    IdentityManager.checkIPMatch();
                }
            }
        }

        static async handleCandidate(msg) {
            if (state.studioPC) {
                try {
                    await state.studioPC.addIceCandidate(new RTCIceCandidate(msg));
                } catch (e) {
                    log(`üéµ [STUDIO] ICE candidate error: ${e.message}`, "err");
                }
            }
        }

        static optimizeSDP(sdp) {
            const opts = CONFIG.SDP_OPTIMIZATION;
            let optimized = sdp;
            
            // Find and enhance Opus codec line
            optimized = optimized.replace(
                "useinbandfec=1",
                `useinbandfec=1;stereo=${opts.stereo ? 1 : 0};sprop-stereo=${opts.stereo ? 1 : 0};` +
                `maxaveragebitrate=${opts.maxBitrate};cbr=${opts.cbr ? 1 : 0};dtx=${opts.dtx ? 1 : 0};` +
                `ptime=${opts.ptime};minptime=${opts.ptime}`
            );
            
            return optimized;
        }

        static startStats() {
            if (state.statsInterval) {
                clearInterval(state.statsInterval);
            }

            let prevBytes = 0;
            let prevTime = Date.now();
            let prevPacketsLost = 0;
            let prevPacketsReceived = 0;

            state.statsInterval = setInterval(async () => {
                if (!state.studioPC || state.studioPC.connectionState !== 'connected') {
                    return;
                }

                try {
                    const stats = await state.studioPC.getStats();
                    
                    stats.forEach(report => {
                        if (report.type === 'inbound-rtp' && report.kind === 'audio') {
                            const now = Date.now();
                            const bytes = report.bytesReceived;
                            
                            // Bitrate calculation
                            if (prevBytes > 0) {
                                const kbps = ((bytes - prevBytes) * 8) / (now - prevTime);
                                state.connectionQuality.bitrate = kbps;
                                
                                if (kbps > 64) {
                                    ui.bitrateEl.innerText = `${kbps.toFixed(0)} kbps`;
                                    ui.bitrateEl.style.display = "block";
                                }
                            }
                            
                            prevBytes = bytes;
                            prevTime = now;
                            
                            // Packet loss calculation
                            const packetsLost = report.packetsLost || 0;
                            const packetsReceived = report.packetsReceived || 0;
                            const totalPackets = packetsLost + packetsReceived;
                            
                            if (totalPackets > 0) {
                                const lossPercent = (packetsLost / totalPackets) * 100;
                                state.connectionQuality.packetLoss = lossPercent;
                            }
                            
                            // Jitter (in seconds, convert to ms)
                            if (report.jitter !== undefined) {
                                state.connectionQuality.jitter = report.jitter * 1000;
                            }
                            
                            // Round-trip time / Latency
                            if (report.roundTripTime !== undefined) {
                                state.connectionQuality.latency = report.roundTripTime * 1000;
                            }
                        }
                    });
                    
                    UIManager.updateConnectionQuality();
                } catch (e) {
                    log(`Stats Error: ${e.message}`, "err");
                }
            }, CONFIG.STATS_INTERVAL);
        }

        static close() {
            if (state.studioPC) {
                state.studioPC.close();
                state.studioPC = null;
            }
            
            if (state.statsInterval) {
                clearInterval(state.statsInterval);
                state.statsInterval = null;
            }
        }
    }

    // ===== SIGNALING / WEBSOCKET MANAGEMENT =====

    class SignalingManager {
        static connect(room, username) {
            if (state.ws && state.ws.readyState === WebSocket.OPEN) {
                log("WebSocket already connected", "warn");
                return;
            }

            try {
                state.ws = new WebSocket(CONFIG.WS_URL);

                state.ws.onopen = () => {
                    log("‚úÖ WebSocket Connected", "success");
                    state.reconnectAttempts = 0;
                    
                    // Send join message
                    this.send({
                        type: 'join',
                        room: room,
                        name: username,
                        id: state.myId,
                        role: 'receiver',
                        isBroadcasting: false
                    });
                };

                state.ws.onmessage = (e) => {
                    try {
                        const msg = JSON.parse(e.data);
                        this.handleMessage(msg);
                    } catch (err) {
                        log(`Message Parse Error: ${err.message}`, "err");
                    }
                };

                state.ws.onerror = (e) => {
                    log("WebSocket Error", "err");
                };

                state.ws.onclose = () => {
                    log("WebSocket Closed", "warn");
                    
                    // Check if studio audio is still flowing
                    const studioConnected = state.studioPC &&
                        (state.studioPC.connectionState === 'connected' ||
                         state.studioPC.connectionState === 'completed');
                    
                    if (studioConnected) {
                        log("‚ö†Ô∏è Signal Lost (Audio Persisting)", "warn");
                        ui.statusDot.classList.add('warn');
                    } else {
                        UIManager.setUIState('disconnected');
                    }
                    
                    // Attempt reconnection
                    this.scheduleReconnect();
                };
            } catch (e) {
                log(`WebSocket Init Failed: ${e.message}`, "err");
                this.scheduleReconnect();
            }
        }

        static scheduleReconnect() {
            if (state.reconnectAttempts >= CONFIG.MAX_RECONNECT_ATTEMPTS) {
                log("üö´ Max reconnection attempts reached", "err");
                UIManager.setUIState('disconnected');
                return;
            }

            const delay = Math.min(
                CONFIG.RECONNECT_BASE_DELAY * Math.pow(2, state.reconnectAttempts),
                CONFIG.RECONNECT_MAX_DELAY
            );

            state.reconnectAttempts++;
            log(`üîÑ Reconnecting in ${(delay / 1000).toFixed(1)}s (attempt ${state.reconnectAttempts})`, "warn");

            state.reconnectTimer = setTimeout(() => {
                if (!state.isConnected) {
                    log("User disconnected, skipping reconnect", "info");
                    return;
                }
                
                this.connect(state.currentRoomName, state.myUserName);
            }, delay);
        }

        static send(message) {
            if (state.ws && state.ws.readyState === WebSocket.OPEN) {
                state.ws.send(JSON.stringify(message));
                return true;
            } else {
                log("Cannot send - WebSocket not connected", "warn");
                return false;
            }
        }

        static handleMessage(msg) {
            // Ignore own messages
            if (msg.id === state.myId) return;

            // Handle roster updates
            if (msg.type === 'roster-update') {
                RosterManager.handleUpdate(msg.roster);
                return;
            }

            // Route to appropriate handler
            const isBroadcaster = (msg.id === state.broadcasterId);
            
            if (isBroadcaster) {
                this.handleStudioMessage(msg);
            } else {
                this.handleVoiceMessage(msg);
            }
        }

        static handleStudioMessage(msg) {
            switch (msg.type) {
                case 'offer':
                    StudioConnectionManager.handleOffer(msg);
                    break;
                case 'candidate':
                    StudioConnectionManager.handleCandidate(msg);
                    break;
            }
        }

        static handleVoiceMessage(msg) {
            switch (msg.type) {
                case 'offer':
                    PeerConnectionManager.handleOffer(msg);
                    break;
                case 'answer':
                    PeerConnectionManager.handleAnswer(msg);
                    break;
                case 'candidate':
                    PeerConnectionManager.handleCandidate(msg);
                    break;
            }
        }

        static broadcastStatus() {
            this.send({
                type: 'status-update',
                id: state.myId,
                isMicEnabled: state.isTalking,
                isMusicEnabled: !state.isMuted
            });
        }

        static close() {
            if (state.reconnectTimer) {
                clearTimeout(state.reconnectTimer);
                state.reconnectTimer = null;
            }
            
            if (state.ws) {
                state.ws.close();
                state.ws = null;
            }
        }
    }

    // ===== ROSTER MANAGEMENT =====

    class RosterManager {
        static handleUpdate(roster) {
            // Deduplicate by ID
            const uniqueMap = new Map();
            roster.forEach(user => uniqueMap.set(user.id, user));
            
            // Detect removed peers and clean them up
            const newRosterIds = new Set(Array.from(uniqueMap.keys()));
            state.currentRoster.forEach(oldUser => {
                if (!newRosterIds.has(oldUser.id) && oldUser.id !== state.myId) {
                    // Peer has left, clean up their connection
                    if (state.voicePeerConnections.has(oldUser.id)) {
                        log(`üó£ Peer ${getName(oldUser.id)} left, cleaning up`, "info");
                        PeerConnectionManager.closePeer(oldUser.id);
                    }
                }
            });
            
            state.currentRoster = Array.from(uniqueMap.values());
            
            this.render();
            
            // Identify broadcaster
            const host = state.currentRoster.find(u => u.isBroadcasting);
            if (host) {
                state.broadcasterId = host.id;
            }
            
            // Initiate peer connections
            this.initiatePeerConnections();
        }

        static initiatePeerConnections() {
            state.currentRoster.forEach(peer => {
                // Skip self and broadcaster
                if (peer.id === state.myId || peer.id === state.broadcasterId) {
                    return;
                }
                
                // Only initiate if we have lower ID (prevents duplicate connections)
                if (state.myId < peer.id &&
                    !state.voicePeerConnections.has(peer.id) &&
                    !state.pendingPeerConnections.has(peer.id)) {
                    
                    // Stagger connections to avoid overwhelming signaling
                    setTimeout(() => {
                        PeerConnectionManager.initiateConnection(peer.id);
                    }, CONFIG.PEER_INIT_DELAY + Math.random() * 500);
                }
            });
        }

        static render() {
            ui.rosterList.innerHTML = '';
            
            // Update participant count
            ui.participantCount.innerText = `${state.currentRoster.length} online`;
            
            // Sort roster: Studio stream first, Studio Monitor second, then others alphabetically
            const sortedRoster = [...state.currentRoster].sort((a, b) => {
                // Studio broadcaster always first
                if (a.isBroadcasting) return -1;
                if (b.isBroadcasting) return 1;
                
                // Studio Monitor second
                if (a.name === "Studio Monitor") return -1;
                if (b.name === "Studio Monitor") return 1;
                
                // Everyone else alphabetically
                return a.name.localeCompare(b.name);
            });
            
            sortedRoster.forEach(user => {
                const isMe = user.id === state.myId;
                const isSender = user.isBroadcasting;
                const isStudioMonitor = user.name === "Studio Monitor";
                let displayName = isMe ? state.myUserName + " (You)" : user.name;

                // Status indicator
                const isActive = isSender ? user.isMusicEnabled : (user.isMicEnabled !== false);
                const statusClass = isActive ? 'active' : 'inactive';

                // Connection status for voice peers
                let statusBadge = '';
                if (!isMe && !isSender) {
                    const connState = getConnectionState(user.id);
                    let statusText = '';
                    let statusClass = '';

                    if (connState === 'connected') {
                        statusText = 'voice connected';
                        statusClass = 'connected';
                    } else if (connState === 'connecting' || connState === 'new') {
                        statusText = 'voice connecting';
                        statusClass = 'connecting';
                    } else if (connState === 'failed' || connState === 'disconnected') {
                        statusText = 'voice reconnecting';
                        statusClass = 'failed';
                    }

                    if (statusText) {
                        statusBadge = `<span class="roster-status ${statusClass}">${statusText}</span>`;
                    }
                }

                // Apply orange color to Studio stream and Studio Monitor
                const nameClass = (isSender || isStudioMonitor) ? 'roster-name-highlight' : 'roster-name';

                const el = document.createElement('div');
                el.className = 'roster-item';

                if (isSender) {
                    // Broadcaster: [name] [horizontal meters] [mic icon]
                    el.innerHTML = `
                        <span class="${nameClass}">${displayName}</span>
                        <div class="roster-meters-horizontal">
                            <div class="h-meter-row"><div id="ml-${user.id}" class="h-meter-fill"></div></div>
                            <div class="h-meter-row"><div id="mr-${user.id}" class="h-meter-fill"></div></div>
                        </div>
                        <div id="status-icon-${user.id}" class="icon-box ${statusClass}">${ICONS.MIC}</div>
                    `;
                } else {
                    // Non-broadcaster: [headphones + name] ... [mic icon]
                    const muteClass = (user.isMusicEnabled !== false) ? 'active' : 'inactive';
                    el.innerHTML = `
                        <div class="roster-left">
                            <div class="icon-box ${muteClass}">${ICONS.HEADPHONES}</div>
                            <span class="${nameClass}">${displayName}${statusBadge}</span>
                        </div>
                        <div id="status-icon-${user.id}" class="icon-box ${statusClass}">${ICONS.MIC}</div>
                    `;
                }
                ui.rosterList.appendChild(el);
            });
        }

        static updateStatus(peerId, status) {
            this.render(); // Re-render to update status badges
        }
    }

    // ===== IDENTITY MANAGEMENT =====

    class IdentityManager {
        static isLocalIP(ip) {
            // Check if IP is localhost or private network address
            if (ip === '127.0.0.1' || ip === '::1') return true;
            if (ip.startsWith('192.168.')) return true;
            if (ip.startsWith('10.')) return true;
            if (ip.startsWith('172.')) {
                const second = parseInt(ip.split('.')[1]);
                if (second >= 16 && second <= 31) return true;
            }
            if (ip.startsWith('169.254.')) return true; // Link-local
            if (ip.startsWith('fe80:')) return true; // IPv6 link-local
            if (ip.startsWith('fc00:') || ip.startsWith('fd00:')) return true; // IPv6 private
            return false;
        }

        static checkIPMatch() {
            // Only check IP match if user didn't provide a name
            if (!state.nameWasEmpty || state.hasRenamedToMonitor) return;
            
            // Filter to only local/private IPs
            const myLocalIPs = Array.from(state.myIPs).filter(ip => this.isLocalIP(ip));
            const senderLocalIPs = Array.from(state.senderIPs).filter(ip => this.isLocalIP(ip));
            
            if (myLocalIPs.length === 0 || senderLocalIPs.length === 0) {
                return; // No local IPs to compare
            }
            
            // Check for localhost first (strongest signal)
            const hasLocalhost = myLocalIPs.some(ip => ip === '127.0.0.1' || ip === '::1') &&
                                 senderLocalIPs.some(ip => ip === '127.0.0.1' || ip === '::1');
            
            if (hasLocalhost) {
                this.activateStudioMonitor();
                return;
            }
            
            // Count matching local IPs (require at least 2 for confidence)
            let matchCount = 0;
            for (let myIP of myLocalIPs) {
                if (senderLocalIPs.includes(myIP)) {
                    matchCount++;
                }
            }
            
            // Only activate if we have 2+ matching local IPs or 1 match with small network
            if (matchCount >= 2 || (matchCount >= 1 && myLocalIPs.length <= 2)) {
                log(`üîç Matched ${matchCount} local IP(s): ${myLocalIPs.join(', ')}`, "info");
                this.activateStudioMonitor();
            }
        }

        static activateStudioMonitor() {
            if (state.hasRenamedToMonitor) return;
            
            state.hasRenamedToMonitor = true;
            
            if (state.verificationTimer) {
                clearTimeout(state.verificationTimer);
                state.verificationTimer = null;
            }
            
            state.nameWasEmpty = false;
            state.myUserName = "Studio Monitor";
            
            log("‚ö°Ô∏è Same Machine Detected ‚Üí 'Studio Monitor'", "success");
            
            // Update the connected-as display if already connected
            if (state.isConnected && ui.connectedAsName) {
                ui.connectedAsName.innerText = state.myUserName;
            }
            
            RosterManager.render();
            
            SignalingManager.send({
                type: 'join',
                room: state.currentRoomName,
                name: state.myUserName,
                id: state.myId,
                role: 'receiver',
                isBroadcasting: false
            });
        }

        static startVerification() {
            const inputUser = ui.userInput.value.trim();
            state.nameWasEmpty = (inputUser === "");
            
            if (state.nameWasEmpty) {
                state.myUserName = "Verifying Identity...";
                log("‚ö†Ô∏è Name Empty. Verifying Local Machine...", "warn");
                
                state.verificationTimer = setTimeout(() => {
                    if (state.nameWasEmpty && !state.hasRenamedToMonitor) {
                        ConnectionManager.disconnectAll();
                        log("üö´ Access Denied: Name Required", "err");
                        alert("Participant identifier required.\n\nYou must enter your name to connect remotely to the studio.");
                    }
                }, CONFIG.VERIFICATION_TIMEOUT);
            } else {
                state.myUserName = inputUser;
            }
        }
    }

    // ===== UI MANAGEMENT =====

    class UIManager {
        static updateButtons() {
            const isActuallySilent = state.isMuted || state.lastVolume === 0;
            
            // Mute button
            if (isActuallySilent) {
                ui.btnMute.className = "slider-btn muted-state";
            } else {
                ui.btnMute.className = "slider-btn active";
            }
            
            document.getElementById('icon-vol').style.display = isActuallySilent ? "none" : "block";
            document.getElementById('icon-mute').style.display = isActuallySilent ? "block" : "none";

            // Talk button
            const talkIconOff = document.getElementById('icon-talk-off');
            const talkIconOn = document.getElementById('icon-talk-on');
            const talkIconFix = document.getElementById('icon-repair');
            
            if (state.isRepairing) {
                ui.btnTalk.className = "slider-btn repairing";
                talkIconOff.style.display = "none";
                talkIconOn.style.display = "none";
                talkIconFix.style.display = "block";
            } else {
                ui.btnTalk.className = state.isTalking ? "slider-btn active" : "slider-btn";
                ui.btnTalk.disabled = !state.localVoiceStream;
                talkIconFix.style.display = "none";
                talkIconOff.style.display = state.isTalking ? "none" : "block";
                talkIconOn.style.display = state.isTalking ? "block" : "none";
            }
        }

        static setUIState(newState) {
            if (newState === 'connecting') {
                ui.btnConnect.innerText = "Connecting...";
                ui.btnConnect.disabled = true;
                ui.setupPanel.style.opacity = "0.5";
            } else if (newState === 'connected') {
                state.isConnected = true;
                ui.statusText.innerText = "LIVE AUDIO";
                ui.statusDot.className = "status-dot on";
                ui.bitrateEl.style.display = "block";
                ui.qualityBadge.style.display = "block";
                ui.networkStats.style.display = "flex";
                ui.connectedAs.style.display = "block";
                ui.connectedAsName.innerText = state.myUserName;
                
                ui.setupPanel.classList.add('hidden');
                ui.controlsPanel.classList.remove('hidden');
                ui.rosterCard.style.display = "flex";
                ui.consoleCard.style.display = "flex";
                ui.disconnectPanel.style.display = "block";

                ui.btnConnect.style.display = "none";
                
                this.updateButtons();
                SignalingManager.broadcastStatus();
            } else { // disconnected
                state.isConnected = false;
                ui.statusText.innerText = "READY";
                ui.statusDot.className = "status-dot";
                ui.bitrateEl.style.display = "none";
                ui.qualityBadge.style.display = "none";
                ui.networkStats.style.display = "none";
                ui.connectedAs.style.display = "none";
                ui.disconnectPanel.style.display = "none";

                ui.setupPanel.classList.remove('hidden');
                ui.setupPanel.style.opacity = "1";
                ui.controlsPanel.classList.add('hidden');
                ui.rosterCard.style.display = "none";
                ui.consoleCard.style.display = "none";

                ui.btnConnect.style.display = "block";
                ui.btnConnect.innerText = "Listen Live";
                ui.btnConnect.disabled = false;
            }
        }

        static updateRosterStatus(peerId, status) {
            RosterManager.updateStatus(peerId, status);
        }

        static updateConnectionQuality() {
            const q = state.connectionQuality;
            
            // Update quality badge
            let qualityText = 'Good';
            let qualityClass = 'good';
            
            if (q.packetLoss > 5 || q.jitter > 100) {
                qualityText = 'Poor';
                qualityClass = 'poor';
            } else if (q.packetLoss < 1 && q.jitter < 30) {
                qualityText = 'Excellent';
                qualityClass = 'excellent';
            }
            
            ui.qualityBadge.innerText = qualityText;
            ui.qualityBadge.className = `status-quality ${qualityClass}`;
            
            // Update network stats
            document.getElementById('stat-latency').innerText =
                q.latency > 0 ? `${q.latency.toFixed(0)}ms` : '--';
            document.getElementById('stat-loss').innerText =
                q.packetLoss > 0 ? `${q.packetLoss.toFixed(1)}%` : '--';
            document.getElementById('stat-jitter').innerText =
                q.jitter > 0 ? `${q.jitter.toFixed(0)}ms` : '--';
        }
    }

    // ===== CONNECTION MANAGER =====

    class ConnectionManager {
        static async connect() {
            state.currentRoomName = ui.roomInput.value || "studio1";
            IdentityManager.startVerification();
            UIManager.setUIState('connecting');

            try {
                // Initialize audio
                const audioOk = await AudioManager.initialize();
                if (!audioOk) {
                    throw new Error("Audio initialization failed");
                }

                // Request microphone
                await AudioManager.requestMicrophone();

                // Connect signaling
                SignalingManager.connect(state.currentRoomName, state.myUserName);
                
                // Start health monitoring
                PeerConnectionManager.startHealthMonitoring();
            } catch (e) {
                log(`Connection Failed: ${e.message}`, "err");
                UIManager.setUIState('disconnected');
            }
        }

        static disconnectAll() {
            log("üîå Disconnecting...", "info");
            
            // Close signaling
            SignalingManager.close();
            
            // Close all peer connections
            StudioConnectionManager.close();
            PeerConnectionManager.closeAll();
            
            // Cleanup audio
            AudioManager.cleanup();
            
            // Reset state
            state.myIPs.clear();
            state.senderIPs.clear();
            state.hasRenamedToMonitor = false;
            state.isRepairing = false;
            state.isTalking = false;
            state.isMuted = false;
            state.broadcasterId = null;
            state.reconnectAttempts = 0;
            state.connectionQuality = { bitrate: 0, latency: 0, packetLoss: 0, jitter: 0 };

            if (state.verificationTimer) {
                clearTimeout(state.verificationTimer);
                state.verificationTimer = null;
            }

            state.nameWasEmpty = false;
            state.currentRoster = [];

            // Reset button visuals to match cleared state
            document.getElementById('icon-vol').style.display = "block";
            document.getElementById('icon-mute').style.display = "none";
            document.getElementById('icon-talk-off').style.display = "block";
            document.getElementById('icon-talk-on').style.display = "none";
            document.getElementById('icon-repair').style.display = "none";

            // Update UI
            UIManager.setUIState('disconnected');
            log("‚úÖ Disconnected", "info");
        }
    }

    // ===== EVENT HANDLERS =====

    ui.btnConnect.addEventListener('click', async () => {
        if (!state.isConnected) {
            ui.consoleCard.style.display = "flex";
            await ConnectionManager.connect();
        }
    });

    ui.btnDisconnect.addEventListener('click', () => {
        ConnectionManager.disconnectAll();
    });

    // Drag handle for disconnect panel
    let startY = 0;
    let currentY = 0;
    let isDragging = false;

    ui.dragHandle.addEventListener('touchstart', (e) => {
        startY = e.touches[0].clientY;
        isDragging = true;
        ui.disconnectPanel.style.transition = 'none';
    });

    ui.dragHandle.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        currentY = e.touches[0].clientY;
        const deltaY = currentY - startY;
        
        if (deltaY > 0) {
            // Dragging down
            ui.disconnectPanel.style.transform = `translateY(calc(100% - 20px + ${Math.min(deltaY, 100)}px))`;
        } else {
            // Dragging up
            ui.disconnectPanel.style.transform = `translateY(${Math.max(deltaY, -80)}px)`;
        }
    });

    ui.dragHandle.addEventListener('touchend', (e) => {
        if (!isDragging) return;
        isDragging = false;
        ui.disconnectPanel.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
        
        const deltaY = currentY - startY;
        if (deltaY > 50) {
            // Collapsed
            ui.disconnectPanel.classList.remove('expanded');
            ui.disconnectPanel.style.transform = '';
        } else if (deltaY < -30) {
            // Expanded
            ui.disconnectPanel.classList.add('expanded');
            ui.disconnectPanel.style.transform = '';
        } else {
            // Return to current state
            ui.disconnectPanel.style.transform = '';
        }
    });

    // Click to toggle
    ui.dragHandle.addEventListener('click', () => {
        ui.disconnectPanel.classList.toggle('expanded');
    });

    // Auto-expand on scroll near bottom, collapse on scroll up
    let scrollTimeout;
    let lastScrollTop = window.scrollY;
    window.addEventListener('scroll', () => {
        if (!state.isConnected) return;

        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
            const scrollHeight = document.documentElement.scrollHeight;
            const scrollTop = window.scrollY;
            const clientHeight = window.innerHeight;

            if (scrollTop < lastScrollTop) {
                // Scrolling up ‚Äî collapse
                ui.disconnectPanel.classList.remove('expanded');
            } else if (scrollTop + clientHeight >= scrollHeight - 50) {
                // At bottom ‚Äî expand
                ui.disconnectPanel.classList.add('expanded');
            }
            lastScrollTop = scrollTop;
        }, 100);
    });

    ui.btnTalk.addEventListener('click', () => {
        if (state.isRepairing) {
            log("[FIX] üîß Manual Repair Initiated", "success");
            state.voicePeerConnections.forEach((session, peerId) => {
                if (session.pc.connectionState === 'failed' ||
                    session.pc.connectionState === 'disconnected') {
                    PeerConnectionManager.restartIce(peerId);
                }
            });
            state.isRepairing = false;
            UIManager.updateButtons();
            return;
        }
        
        if (!state.localVoiceStream) {
            log("No Microphone Available", "err");
            return;
        }
        
        state.isTalking = !state.isTalking;
        state.localVoiceStream.getAudioTracks().forEach(t => t.enabled = state.isTalking);
        // Propagate to all peer connection senders for robustness
        state.voicePeerConnections.forEach((session) => {
            session.pc.getSenders().forEach(sender => {
                if (sender.track && sender.track.kind === 'audio') {
                    sender.track.enabled = state.isTalking;
                }
            });
        });
        log(state.isTalking ? "üéô Mic LIVE" : "üéô Mic Muted", "mic");
        UIManager.updateButtons();
        SignalingManager.broadcastStatus();
    });

    ui.volSlider.addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        if (!state.isMuted) {
            state.lastVolume = val;
            AudioManager.setVolume(val);
        } else {
            state.lastVolume = val;
        }
        UIManager.updateButtons();
    });

    ui.voiceVolSlider.addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        state.lastVoiceVolume = val;
        AudioManager.setVoiceVolume(val);
    });

    ui.btnMute.addEventListener('click', () => {
        state.isMuted = !state.isMuted;
        if (state.isMuted) {
            AudioManager.setVolume(0);
        } else {
            AudioManager.setVolume(state.lastVolume);
        }
        UIManager.updateButtons();
        SignalingManager.broadcastStatus();
    });

    ui.btnClearConsole.addEventListener('click', () => {
        ui.logEl.innerHTML = '';
        log("Console cleared", "info");
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        // Space bar for push-to-talk (when not focused on input)
        if (e.code === 'Space' && document.activeElement.tagName !== 'INPUT') {
            e.preventDefault();
            if (state.isConnected && state.localVoiceStream && !state.isTalking) {
                ui.btnTalk.click();
            }
        }
        
        // M for mute toggle
        if (e.code === 'KeyM' && e.ctrlKey) {
            e.preventDefault();
            ui.btnMute.click();
        }
    });

    document.addEventListener('keyup', (e) => {
        // Release space bar to stop talking
        if (e.code === 'Space' && state.isTalking) {
            e.preventDefault();
            ui.btnTalk.click();
        }
    });

    // Initialize
    log("üéô Rewired Studio Monitor Ready", "success");
    log("Press Space for push-to-talk, Ctrl+M to mute", "info");
})();
</script>
</body>
</html>
